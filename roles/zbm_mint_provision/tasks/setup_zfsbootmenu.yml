---
- name: Format EFI system partition
  ansible.builtin.filesystem:
    fstype: vfat
    dev: "{{ boot_part_device }}"
    opts: "-F32"

- name: Ensure EFI mount directory exists
  ansible.builtin.file:
    path: "{{ chroot_path }}/boot/efi"
    state: directory

- name: Mount EFI system partition in chroot
  ansible.posix.mount:
    path: "{{ chroot_path }}/boot/efi"
    src: "{{ boot_part_device }}"
    fstype: vfat
    opts: defaults
    state: mounted
    fstab: "{{ chroot_path }}/etc/fstab"
    #TODO Does this use the UUID automatically?

- name: Create ZFSBootMenu EFI directory
  ansible.builtin.file:
    path: "{{ chroot_path }}/boot/efi/EFI/ZBM"
    state: directory

- name: Download ZFSBootMenu EFI binary
  ansible.builtin.get_url:
    url: https://get.zfsbootmenu.org/efi
    dest: "{{ zbm_efi_primary_path }}"
    mode: '0644'

- name: Create backup ZFSBootMenu EFI binary
  ansible.builtin.copy:
    src: "{{ zbm_efi_primary_path }}"
    dest: "{{ zbm_efi_backup_path }}"
    remote_src: true

- name: Ensure efivarfs is mounted for chroot
  ansible.posix.mount:
    path: "{{ chroot_path }}/sys/firmware/efi/efivars"
    src: efivarfs
    fstype: efivarfs
    state: mounted

- name: Configure EFI boot entries directly with efibootmgr
  when: efi_boot_method == 'direct'
  block:
    - name: (Chroot) Create backup ZFSBootMenu EFI boot entry
      ansible.builtin.command:
        argv:
          - efibootmgr
          - -c
          - -d
          - "{{ boot_disk }}"
          - -p
          - "{{ boot_part_num }}"
          - -L
          - ZFSBootMenu (Backup)
          - -l
          - '\EFI\ZBM\VMLINUZ-BACKUP.EFI'
      delegate_to: "{{ chroot_path }}"
      become: true

    - name: (Chroot) Create ZFSBootMenu EFI boot entry
      ansible.builtin.command:
        argv:
          - efibootmgr
          - -c
          - -d
          - "{{ boot_disk }}"
          - -p
          - "{{ boot_part_num }}"
          - -L
          - ZFSBootMenu
          - -l
          - '\EFI\ZBM\VMLINUZ.EFI'
      delegate_to: "{{ chroot_path }}"
      become: true

- name: Configure EFI boot entries with rEFInd
  when: efi_boot_method == 'refind'
  block:
    - name: (Chroot) Create symlink for /etc/mtab
      ansible.builtin.file:
        src: /proc/self/mounts
        dest: "{{ chroot_path }}/etc/mtab"
        state: link
        force: true
      become: true

    - name: (Chroot) Install refind
      ansible.builtin.apt:
        name: refind
        state: present
        update_cache: true
      delegate_to: "{{ chroot_path }}"
      become: true

    - name: (Chroot) Run refind-install
      ansible.builtin.command:
        cmd: refind-install
      delegate_to: "{{ chroot_path }}"
      become: true

    - name: (Chroot) Remove default refind_linux.conf
      ansible.builtin.file:
        path: "{{ chroot_path }}/boot/refind_linux.conf"
        state: absent
      become: true

    - name: (Chroot) Create ZBM-specific refind_linux.conf
      ansible.builtin.copy:
        dest: "{{ chroot_path }}/boot/efi/EFI/ZBM/refind_linux.conf"
        content: |
          "Boot default"  "quiet loglevel=0 zbm.skip"
          "Boot to menu"  "quiet loglevel=0 zbm.show"
        mode: '0644'
      become: true

- name: Check for rEFInd EFI binary
  ansible.builtin.stat:
    path: "{{ secure_boot_refind_efi_path }}"
  register: refind_efi
  when: secure_boot_sign | bool and efi_boot_method == 'refind'

- name: Build secure boot signing file list
  ansible.builtin.set_fact:
    secure_boot_sign_files: >-
      {{
        [
          zbm_efi_primary_path,
          zbm_efi_backup_path
        ]
        + (
          [secure_boot_refind_efi_path]
          if (
            efi_boot_method == 'refind'
            and refind_efi is defined
            and refind_efi.stat.exists
          )
          else []
        )
        + (secure_boot_sign_extra_efi_files | default([]))
      }}
  when: secure_boot_sign | bool

- name: Initialize secure boot signing list
  ansible.builtin.set_fact:
    secure_boot_sign_pending: []
  when: secure_boot_sign | bool

- name: Check EFI binaries for existing signatures
  ansible.builtin.command:
    argv:
      - sbverify
      - --cert
      - "{{ secure_boot_sign_cert_path }}"
      - "{{ item }}"
  register: secure_boot_sign_verify
  failed_when: false
  changed_when: false
  loop: "{{ secure_boot_sign_files }}"
  when: secure_boot_sign | bool

- name: Log EFI binaries requiring signing
  ansible.builtin.debug:
    msg: >-
      EFI binary {{ item.item }} requires signing (sbverify rc={{ item.rc }}):
      {{ item.stderr | default('no stderr output') }}
    verbosity: 1
  loop: "{{ secure_boot_sign_verify.results | default([]) }}"
  when:
    - secure_boot_sign | bool
    - item.rc != 0

- name: Build list of EFI binaries needing signing
  ansible.builtin.set_fact:
    secure_boot_sign_pending: "{{ secure_boot_sign_pending + [item.item] }}"
  loop: "{{ secure_boot_sign_verify.results | default([]) }}"
  when:
    - secure_boot_sign | bool
    - item.rc != 0

- name: Sign EFI binaries for secure boot
  ansible.builtin.command:
    argv:
      - sbsign
      - --key
      - "{{ secure_boot_sign_key_path }}"
      - --cert
      - "{{ secure_boot_sign_cert_path }}"
      - --output
      - "{{ item }}{{ secure_boot_sign_temp_suffix }}"
      - "{{ item }}"
  register: secure_boot_sign_result
  changed_when: secure_boot_sign_result.rc == 0
  failed_when: secure_boot_sign_result.rc != 0
  no_log: "{{ secure_boot_sign_no_log }}"
  loop: "{{ secure_boot_sign_pending | default([]) }}"
  when:
    - secure_boot_sign | bool
    - secure_boot_sign_pending | default([]) | length > 0

- name: Replace EFI binaries with signed versions
  ansible.builtin.copy:
    src: "{{ item }}{{ secure_boot_sign_temp_suffix }}"
    dest: "{{ item }}"
    mode: '0644'
    remote_src: true
  loop: "{{ secure_boot_sign_pending | default([]) }}"
  when:
    - secure_boot_sign | bool
    - secure_boot_sign_pending | default([]) | length > 0

- name: Verify signed EFI binaries
  ansible.builtin.command:
    argv:
      - sbverify
      - --cert
      - "{{ secure_boot_sign_cert_path }}"
      - "{{ item }}"
  register: secure_boot_sign_verify_signed
  changed_when: false
  failed_when: secure_boot_sign_verify_signed.rc != 0
  loop: "{{ secure_boot_sign_pending | default([]) }}"
  when:
    - secure_boot_sign | bool
    - secure_boot_sign_pending | default([]) | length > 0

- name: Remove secure boot signing temporary files
  ansible.builtin.file:
    path: "{{ item }}{{ secure_boot_sign_temp_suffix }}"
    state: absent
  loop: "{{ secure_boot_sign_pending | default([]) }}"
  when:
    - secure_boot_sign | bool
    - secure_boot_sign_pending | default([]) | length > 0
...
