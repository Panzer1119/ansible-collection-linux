---
# Disk Configuration
boot_disk: "/dev/sda"
boot_part_num: "1"
pool_disk: "/dev/sda"
pool_part_num: "2"
# If true, partition paths will be rendered as /dev/nvme0n1p1 (note the "p").
# If false, partition paths will be rendered as /dev/sda1.
is_nvme: false

# Live / Chroot Provisioning
# Optional APT proxy URL (e.g. http://aptproxy.local:3142). When set, a proxy
# config is written into the target system under /etc/apt/apt.conf.d/90proxy.
apt_proxy: ""
installation_method: "squashfs"  # Options: "squashfs", "debootstrap"
apt_sources: "official"          # Options: "official", "custom"
chroot_path: "/mnt"

# ZFS Configuration
pool_name: "zroot"
# Boot environment identifier.
# This role will create a boot environment dataset:
#   {{ pool_name }}/ROOT/{{ zfs_dataset_id }}
# If you want a different naming scheme (ROOT/<id>), set
# zfs_dataset_id accordingly (e.g. "linuxmint").
# Derived from ansible_lsb facts when available (id is the distro ID; codename is the release codename, while release is the version number).
# Uses ansible_lsb.id lowercased. The fallback assumes Linux Mint; override for
# IDs like "Ubuntu" or "Debian" if you need a different dataset name.
zfs_dataset_id: "{{ ((ansible_lsb | default({})).id | default('linuxmint')) | lower }}"

# Boot environment dataset path (mounted at /) under which additional datasets are created.
# Final dataset name will be: {{ zfs_dataset_base }}/<item.name>
zfs_dataset_base: "{{ pool_name }}/ROOT/{{ zfs_dataset_id }}"

#zfs_deduplication: "on"
zfs_compression: "zstd"

# Additional datasets to create beneath {{ zfs_dataset_base }}.
# Each item:
# - name: required, relative dataset path under zfs_dataset_base
# - mountpoint: optional, defaults to "/<name>"
# - canmount: optional, defaults to "on" (use "off" for containers)
#
# Notes:
# - The boot environment dataset itself ({{ zfs_dataset_base }}) is created
#   explicitly by the role and mounted at '/'.
# - Use container datasets with canmount=off to allow child datasets to mount.
# - Keep this list fairly small; add deeper splits only if you snapshot/rollback
#   them independently.
zfs_additional_datasets: []
# Example items (uncomment to enable):
#   # Ubuntu-style containers
#   - name: "usr"
#     canmount: "off"
#   - name: "usr/local"
#   - name: "var"
#     canmount: "off"
#
#   # Commonly useful splits
#   - name: "srv"
#   - name: "var/log"
#   - name: "var/lib"
#
#   # Mint/Ubuntu specific state (optional; safe defaults)
#   - name: "var/lib/AccountsService"
#   - name: "var/lib/NetworkManager"
#   - name: "var/lib/apt"
#   - name: "var/lib/dpkg"
#
#   # Other optional locations
#   - name: "var/games"
#   - name: "var/mail"
#   - name: "var/snap"
#   - name: "var/spool"
#   - name: "var/www"

# User/root datasets (created at pool level by default)
# This mirrors Ubuntu's USERDATA concept.
zfs_userdata_base: "{{ pool_name }}/USERDATA"
zfs_userdata_datasets:
  - name: "{{ default_user_name }}"
  - name: "root"
    mountpoint: "/root"

# System Configuration
hostname: "linux-mint-zbm-test-vm"
root_password: "password" # Use a hashed password in production
default_user_name: "panzer1119"
default_user_password: "password" # Use a hashed password in production
timezone: "Europe/Berlin"

# OS Versions (prefer ansible_lsb facts when available)
ubuntu_codename: "noble"
mint_codename: "{{ (ansible_lsb | default({})).codename | default('zara') }}"
mint_release: "{{ ((ansible_lsb | default({})).release | default('22.2')) }}"
# Ensure base-files version pins include a three-part release (base-files expects X.Y.Z).
mint_version: >-
  {{
    mint_release ~ '.0'
    if mint_release is match('^\\d+\\.\\d+$')
    else mint_release
  }}
mint_keyring_url: "http://packages.linuxmint.com/pool/main/l/linuxmint-keyring/linuxmint-keyring_2022.06.21_all.deb"

# Localization
mint_timezone: "Europe/Berlin"
mint_locales:
  default: "en_US.UTF-8"
  generate:
    - "en_US.UTF-8"
    - "de_DE.UTF-8"
mint_keyboard:
  layout: "de"
  model: "pc105"
  variant: "nodeadkeys"
  options: ""
skip_configuration: false

# Optional extra packages to install at the end of provisioning
chroot_extra_packages: []
